# Task Master MCP 서버 구현 가이드

## **MCP 서버 아키텍처**

### **전체 구조**
```
mcp-server/
├── server.js                    # 서버 진입점
├── src/
│   ├── index.js                # 서버 설정
│   ├── tools/                  # MCP 도구 구현
│   ├── core/                   # 핵심 로직 래퍼
│   │   ├── direct-functions/   # Direct 함수들
│   │   └── utils/              # 유틸리티
│   └── providers/              # MCP 제공자
└── package.json
```

### **서버 설정 패턴**
```javascript
// ✅ DO: MCP 서버 표준 설정
import { FastMCP } from '@modelcontextprotocol/sdk/server/fastmcp';
import { registerAllTools } from './src/tools/index.js';

const server = new FastMCP({
    name: 'task-master-mcp',
    version: '1.0.0'
});

// 도구 등록
registerAllTools(server);

// 서버 시작
server.listen();
```

## **MCP 도구 구현**

### **도구 등록 패턴**
```javascript
// ✅ DO: MCP 도구 표준 등록
export function registerToolNameTool(server) {
    server.addTool({
        name: "tool_name",
        description: "Tool description for task management",
        inputSchema: {
            type: "object",
            properties: {
                projectRoot: {
                    type: "string",
                    description: "Project root directory path"
                },
                // 기타 파라미터들
            },
            required: ["projectRoot"]
        },
        execute: withNormalizedProjectRoot(async (args, { log, session }) => {
            try {
                const result = await toolNameDirect(args, log, { session });
                return handleApiResult(result, log);
            } catch (error) {
                return handleApiError(error, log);
            }
        })
    });
}
```

### **Direct Function 래퍼 패턴**
```javascript
// ✅ DO: MCP용 핵심 로직 래퍼
export async function toolNameDirect(args, log, context = {}) {
    const { session } = context;
    
    try {
        // 경로 정규화
        const tasksPath = findTasksJsonPath(args, log);
        
        // Silent 모드 활성화 (콘솔 출력 방지)
        enableSilentMode();
        
        try {
            // 핵심 로직 호출
            const coreResult = await performToolNameAction(
                tasksPath,
                { /* parameters */ },
                { 
                    session,
                    mcpLog: createLogWrapper(log),
                    projectRoot: args.projectRoot,
                    commandNameFromContext: 'mcp_tool_tool_name',
                    outputType: 'mcp'
                },
                'json'
            );

            return {
                success: true,
                data: {
                    operationSpecificData: coreResult.actionData,
                    telemetryData: coreResult.telemetryData
                }
            };
        } finally {
            // Silent 모드 비활성화
            disableSilentMode();
        }
    } catch (error) {
        log.error(`Error in toolNameDirect: ${error.message}`);
        return { 
            success: false, 
            error: { 
                code: 'OPERATION_ERROR', 
                message: error.message 
            }
        };
    }
}
```

## **경로 처리 및 유틸리티**

### **경로 정규화**
```javascript
// ✅ DO: withNormalizedProjectRoot HOF 사용
import { withNormalizedProjectRoot } from './utils.js';

export function registerToolNameTool(server) {
    server.addTool({
        // ... 도구 정의
        execute: withNormalizedProjectRoot(async (args, { log, session }) => {
            // args.projectRoot가 정규화됨
            const result = await toolNameDirect(args, log, { session });
            return handleApiResult(result, log);
        })
    });
}
```

### **경로 유틸리티**
```javascript
// ✅ DO: 경로 처리 유틸리티 사용
import { findTasksJsonPath } from '../utils/path-utils.js';

export async function toolNameDirect(args, log, context = {}) {
    // 프로젝트 루트 기반 경로 해결
    const tasksPath = findTasksJsonPath(args, log);
    
    // 추가 경로 검증
    if (!fs.existsSync(tasksPath)) {
        throw new Error(`Tasks file not found: ${tasksPath}`);
    }
    
    // 핵심 로직 호출
}
```

## **Silent 모드 구현**

### **Silent 모드 패턴**
```javascript
// ✅ DO: Silent 모드 표준 구현
import { enableSilentMode, disableSilentMode, isSilentMode } from '../../../../scripts/modules/utils.js';

export async function toolNameDirect(args, log, context = {}) {
    try {
        // Silent 모드 활성화
        enableSilentMode();
        
        try {
            // 핵심 로직 호출 (콘솔 출력 방지)
            const result = await performCoreLogic(args);
            
            return {
                success: true,
                data: result
            };
        } finally {
            // 항상 Silent 모드 비활성화
            disableSilentMode();
        }
    } catch (error) {
        return {
            success: false,
            error: { message: error.message }
        };
    }
}
```

### **Silent 모드 상태 확인**
```javascript
// ✅ DO: Silent 모드 상태 확인 함수 사용
if (!isSilentMode()) {
    // 콘솔 출력이 허용된 경우에만 실행
    console.log('Processing...');
}
```

## **로깅 및 에러 처리**

### **MCP 로거 래퍼**
```javascript
// ✅ DO: MCP 로거 래퍼 사용
import { createLogWrapper } from '../utils.js';

export async function toolNameDirect(args, log, context = {}) {
    const mcpLog = createLogWrapper(log);
    
    try {
        mcpLog.info('Starting tool execution');
        
        // 핵심 로직 실행
        
        mcpLog.info('Tool execution completed successfully');
        return { success: true, data: result };
    } catch (error) {
        mcpLog.error(`Tool execution failed: ${error.message}`);
        return { success: false, error: { message: error.message } };
    }
}
```

### **에러 처리 패턴**
```javascript
// ✅ DO: 표준화된 에러 처리
export async function toolNameDirect(args, log, context = {}) {
    try {
        // 파라미터 검증
        if (!args.requiredParam) {
            throw new Error('Required parameter missing');
        }
        
        // 핵심 로직 실행
        const result = await performCoreLogic(args);
        
        return { success: true, data: result };
    } catch (error) {
        log.error(`Error in toolNameDirect: ${error.message}`);
        
        // 에러 타입별 처리
        if (error instanceof ConfigurationError) {
            return {
                success: false,
                error: {
                    code: 'CONFIGURATION_ERROR',
                    message: error.message
                }
            };
        }
        
        return {
            success: false,
            error: {
                code: 'OPERATION_ERROR',
                message: error.message
            }
        };
    }
}
```

## **캐싱 및 성능 최적화**

### **캐싱 구현**
```javascript
// ✅ DO: 캐싱 패턴 사용
import { getCachedOrExecute } from '../utils/cache-utils.js';

export async function toolNameDirect(args, log, context = {}) {
    const cacheKey = generateCacheKey(args);
    
    return await getCachedOrExecute(cacheKey, async () => {
        // 실제 로직 실행
        const result = await performCoreLogic(args);
        return { success: true, data: result };
    });
}
```

### **비동기 작업 관리**
```javascript
// ✅ DO: AsyncOperationManager 사용
import { AsyncOperationManager } from '../utils/async-operation-manager.js';

const asyncOperationManager = new AsyncOperationManager();

export function registerLongRunningTool(server) {
    server.addTool({
        name: "long-running-tool",
        description: "Long running operation",
        inputSchema: {
            type: "object",
            properties: {
                projectRoot: { type: "string" }
            }
        },
        execute: withNormalizedProjectRoot(async (args, { log, session }) => {
            const operationId = asyncOperationManager.addOperation(async () => {
                return await performLongRunningTask(args);
            });
            
            return {
                operationId,
                status: 'started'
            };
        })
    });
}
```

## **태그 시스템 지원**

### **태그 인식 MCP 도구**
```javascript
// ✅ DO: 태그 시스템 지원
export async function toolNameDirect(args, log, context = {}) {
    const { session } = context;
    
    // 태그 해결
    const tag = args.tag || getCurrentTag(args.projectRoot) || 'master';
    
    // 태그 컨텍스트 전달
    const coreContext = {
        session,
        mcpLog: createLogWrapper(log),
        projectRoot: args.projectRoot,
        commandNameFromContext: 'mcp_tool_tool_name',
        outputType: 'mcp',
        tag // 태그 정보 포함
    };
    
    // 핵심 로직 호출 (태그 인식)
    const result = await performCoreLogic(args, coreContext);
    
    return { success: true, data: result };
}
```

### **태그 관리 도구**
```javascript
// ✅ DO: 태그 관리 MCP 도구
export function registerTagManagementTools(server) {
    // 태그 목록 조회
    server.addTool({
        name: "list_tags",
        description: "List all available tags",
        inputSchema: {
            type: "object",
            properties: {
                projectRoot: { type: "string" },
                showMetadata: { type: "boolean" }
            }
        },
        execute: withNormalizedProjectRoot(async (args, { log, session }) => {
            const result = await listTagsDirect(args, log, { session });
            return handleApiResult(result, log);
        })
    });
    
    // 태그 생성
    server.addTool({
        name: "add_tag",
        description: "Create a new tag",
        inputSchema: {
            type: "object",
            properties: {
                projectRoot: { type: "string" },
                tagName: { type: "string" },
                description: { type: "string" }
            },
            required: ["projectRoot", "tagName"]
        },
        execute: withNormalizedProjectRoot(async (args, { log, session }) => {
            const result = await addTagDirect(args, log, { session });
            return handleApiResult(result, log);
        })
    });
}
```

## **텔레메트리 통합**

### **텔레메트리 데이터 전파**
```javascript
// ✅ DO: 텔레메트리 데이터 전파
export async function toolNameDirect(args, log, context = {}) {
    try {
        const coreResult = await performCoreLogic(args, context);
        
        return {
            success: true,
            data: {
                operationSpecificData: coreResult.actionData,
                telemetryData: coreResult.telemetryData // 텔레메트리 포함
            }
        };
    } catch (error) {
        return { success: false, error: { message: error.message } };
    }
}
```

### **API 결과 처리**
```javascript
// ✅ DO: handleApiResult 사용
import { handleApiResult } from './utils.js';

export function registerToolNameTool(server) {
    server.addTool({
        // ... 도구 정의
        execute: withNormalizedProjectRoot(async (args, { log, session }) => {
            const result = await toolNameDirect(args, log, { session });
            return handleApiResult(result, log); // 텔레메트리 처리 포함
        })
    });
}
```

## **테스트 및 검증**

### **MCP 도구 테스트**
```javascript
// ✅ DO: MCP 도구 테스트 패턴
describe('MCP Tool Tests', () => {
    let mockServer;
    let mockLog;
    
    beforeEach(() => {
        mockServer = {
            addTool: jest.fn()
        };
        mockLog = {
            info: jest.fn(),
            error: jest.fn(),
            warn: jest.fn()
        };
    });
    
    it('should register tool correctly', () => {
        registerToolNameTool(mockServer);
        expect(mockServer.addTool).toHaveBeenCalledWith({
            name: 'tool_name',
            description: expect.any(String),
            inputSchema: expect.any(Object),
            execute: expect.any(Function)
        });
    });
    
    it('should handle tool execution correctly', async () => {
        const args = { projectRoot: '/test/path' };
        const context = { session: {} };
        
        const result = await toolNameDirect(args, mockLog, context);
        
        expect(result).toHaveProperty('success');
        expect(result.success).toBe(true);
    });
});
```

### **Direct Function 테스트**
```javascript
// ✅ DO: Direct Function 테스트
describe('toolNameDirect', () => {
    it('should return success with data', async () => {
        const args = { projectRoot: '/test/path' };
        const mockLog = { error: jest.fn() };
        const context = { session: {} };
        
        // 핵심 로직 모킹
        jest.spyOn(coreLogic, 'performCoreLogic').mockResolvedValue({
            actionData: { result: 'success' },
            telemetryData: { tokens: 100 }
        });
        
        const result = await toolNameDirect(args, mockLog, context);
        
        expect(result.success).toBe(true);
        expect(result.data.operationSpecificData).toEqual({ result: 'success' });
        expect(result.data.telemetryData).toEqual({ tokens: 100 });
    });
    
    it('should handle errors gracefully', async () => {
        const args = { projectRoot: '/test/path' };
        const mockLog = { error: jest.fn() };
        const context = { session: {} };
        
        // 에러 시뮬레이션
        jest.spyOn(coreLogic, 'performCoreLogic').mockRejectedValue(
            new Error('Test error')
        );
        
        const result = await toolNameDirect(args, mockLog, context);
        
        expect(result.success).toBe(false);
        expect(result.error.message).toBe('Test error');
        expect(mockLog.error).toHaveBeenCalled();
    });
});
```

## **성능 최적화**

### **메모리 관리**
```javascript
// ✅ DO: 메모리 효율적인 구현
export async function toolNameDirect(args, log, context = {}) {
    // 큰 데이터 처리 시 스트리밍 사용
    if (args.largeData) {
        return await processLargeDataStream(args, log);
    }
    
    // 일반적인 경우
    const result = await performCoreLogic(args);
    return { success: true, data: result };
}
```

### **병렬 처리**
```javascript
// ✅ DO: 병렬 처리 활용
export async function batchToolDirect(args, log, context = {}) {
    const { items } = args;
    
    // 병렬 처리로 성능 향상
    const results = await Promise.all(
        items.map(item => processItem(item))
    );
    
    return {
        success: true,
        data: { results }
    };
}
```

---

**참고 파일:**
- [mcp-server/](mdc:mcp-server/) - MCP 서버 구현
- [scripts/modules/](mdc:scripts/modules/) - 핵심 로직 모듈
- [tools/utils.js](mdc:mcp-server/src/tools/utils.js) - MCP 도구 유틸리티

## Telemetry Integration

- Direct functions calling core logic that involves AI should receive and pass through `telemetryData` within their successful `data` payload. See [`telemetry.mdc`](mdc:.cursor/rules/telemetry.mdc) for the standard pattern.
- MCP tools use `handleApiResult`, which ensures the `data` object (potentially including `telemetryData`) from the direct function is correctly included in the final response.
