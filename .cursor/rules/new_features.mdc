# Task Garage 새 기능 통합 가이드

## **새 기능 개발 워크플로우**

### **기능 개발 단계**
```
1. 요구사항 분석 → 2. 핵심 로직 구현 → 3. CLI 명령어 추가 → 4. MCP 도구 구현 → 5. 테스트 작성 → 6. 문서화
```

### **기능 구현 순서**
```javascript
// ✅ DO: 표준 기능 구현 순서
// 1. 핵심 로직 (scripts/modules/task-manager/)
// 2. CLI 명령어 (scripts/modules/commands.js)
// 3. MCP Direct Function (mcp-server/src/core/direct-functions/)
// 4. MCP 도구 (mcp-server/src/tools/)
// 5. 테스트 (tests/unit/, tests/integration/)
```

## **핵심 로직 구현**

### **새 태스크 관리 기능**
```javascript
// ✅ DO: scripts/modules/task-manager/new-feature.js
import { generateTextService } from '../ai-services-unified.js';
import { findTaskById, updateTask } from './task-manager.js';

export async function performNewFeature(tasksPath, taskId, options, context = {}) {
    try {
        // 1. 입력 검증
        validateNewFeatureInput(taskId, options);
        
        // 2. 태스크 조회
        const task = await findTaskById(taskId, tasksPath);
        if (!task) {
            throw new Error(`태스크 ${taskId}를 찾을 수 없습니다`);
        }
        
        // 3. AI 서비스 호출 (필요한 경우)
        const aiResponse = await generateTextService({
            prompt: buildNewFeaturePrompt(task, options),
            model: getConfiguredModel('main'),
            commandName: 'new-feature',
            outputType: context.mcpLog ? 'mcp' : 'cli'
        });
        
        // 4. 결과 처리
        const result = processNewFeatureResult(aiResponse.mainResult, task);
        
        // 5. 태스크 업데이트
        await updateTask(taskId, result, tasksPath);
        
        return {
            success: true,
            data: result,
            telemetryData: aiResponse.telemetryData
        };
    } catch (error) {
        throw new Error(`새 기능 실행 실패: ${error.message}`);
    }
}

function validateNewFeatureInput(taskId, options) {
    if (!taskId) {
        throw new Error('태스크 ID가 필요합니다');
    }
    
    if (!options.requiredParam) {
        throw new Error('필수 파라미터가 누락되었습니다');
    }
}

function buildNewFeaturePrompt(task, options) {
    return `태스크 "${task.title}"에 대해 새 기능을 적용하세요.

태스크 정보:
- ID: ${task.id}
- 제목: ${task.title}
- 설명: ${task.description}
- 상태: ${task.status}

옵션: ${JSON.stringify(options)}

위 정보를 바탕으로 새 기능을 구현해주세요.`;
}

function processNewFeatureResult(aiResult, originalTask) {
    // AI 결과를 태스크 업데이트 형식으로 변환
    return {
        ...originalTask,
        details: aiResult,
        updatedAt: new Date().toISOString()
    };
}
```

### **AI 기반 기능 구현**
```javascript
// ✅ DO: AI 기반 기능 표준 패턴
export async function aiPoweredFeature(tasksPath, prompt, options, context = {}) {
    try {
        // 1. 컨텍스트 수집
        const contextData = await gatherContext({
            tasksPath,
            includeSubtasks: options.includeSubtasks,
            includeDependencies: options.includeDependencies,
            customContext: options.customContext
        });
        
        // 2. AI 프롬프트 구성
        const enhancedPrompt = buildEnhancedPrompt(prompt, contextData, options);
        
        // 3. AI 서비스 호출
        const aiResponse = await generateTextService({
            prompt: enhancedPrompt,
            model: getConfiguredModel(options.useResearch ? 'research' : 'main'),
            maxTokens: options.maxTokens || 2000,
            temperature: options.temperature || 0.7,
            commandName: 'ai-powered-feature',
            outputType: context.mcpLog ? 'mcp' : 'cli'
        });
        
        // 4. 결과 처리 및 저장
        const result = await processAndSaveResult(aiResponse.mainResult, options);
        
        return {
            success: true,
            data: result,
            telemetryData: aiResponse.telemetryData
        };
    } catch (error) {
        throw new Error(`AI 기반 기능 실행 실패: ${error.message}`);
    }
}
```

## **CLI 명령어 추가**

### **새 명령어 등록**
```javascript
// ✅ DO: scripts/modules/commands.js에 새 명령어 추가
programInstance
    .command('new-feature')
    .description('새로운 기능을 실행합니다')
    .option('-i, --id <id>', '태스크 ID')
    .option('-p, --param <value>', '필수 파라미터')
    .option('-o, --output <format>', '출력 형식', 'text')
    .option('--tag <tag>', '태그 컨텍스트 지정')
    .option('-f, --file <file>', '태스크 파일 경로', TASKMASTER_TASKS_FILE)
    .action(async (options) => {
        try {
            // TaskMaster 초기화
            const taskMaster = initTaskMaster({
                tasksPath: options.file || true,
                tag: options.tag
            });
            
            const projectRoot = taskMaster.getProjectRoot();
            const tasksPath = taskMaster.getTasksPath();
            const tag = taskMaster.getTag();
            
            // 새 기능 실행
            const result = await performNewFeature(
                tasksPath,
                options.id,
                {
                    param: options.param,
                    outputFormat: options.output
                },
                {
                    projectRoot,
                    tag,
                    outputFormat: options.output
                }
            );
            
            // 결과 표시
            if (options.output === 'json') {
                console.log(JSON.stringify(result, null, 2));
            } else {
                displayNewFeatureResult(result);
            }
            
            // 텔레메트리 표시
            if (result.telemetryData) {
                displayAiUsageSummary(result.telemetryData, 'cli');
            }
        } catch (error) {
            console.error(chalk.red(`오류: ${error.message}`));
            process.exit(1);
        }
    });
```

### **결과 표시 함수**
```javascript
// ✅ DO: 사용자 친화적 결과 표시
function displayNewFeatureResult(result) {
    console.log(chalk.green('✓ 새 기능이 성공적으로 실행되었습니다'));
    console.log();
    
    if (result.data.taskId) {
        console.log(chalk.cyan(`태스크 ID: ${result.data.taskId}`));
    }
    
    if (result.data.summary) {
        console.log(chalk.white('요약:'));
        console.log(result.data.summary);
        console.log();
    }
    
    if (result.data.details) {
        console.log(chalk.white('상세 정보:'));
        console.log(result.data.details);
    }
}
```

## **MCP 도구 구현**

### **Direct Function 구현**
```javascript
// ✅ DO: mcp-server/src/core/direct-functions/new-feature.js
import { performNewFeature } from '../../../../scripts/modules/task-manager/new-feature.js';
import { findTasksJsonPath } from '../utils/path-utils.js';
import { enableSilentMode, disableSilentMode } from '../../../../scripts/modules/utils.js';

export async function newFeatureDirect(args, log, context = {}) {
    const { session } = context;
    
    try {
        // 경로 해결
        const tasksPath = findTasksJsonPath(args, log);
        
        // Silent 모드 활성화
        enableSilentMode();
        
        try {
            // 핵심 로직 호출
            const result = await performNewFeature(
                tasksPath,
                args.taskId,
                {
                    param: args.param,
                    outputFormat: 'json'
                },
                {
                    session,
                    mcpLog: createLogWrapper(log),
                    projectRoot: args.projectRoot,
                    commandNameFromContext: 'mcp_new_feature',
                    outputType: 'mcp'
                }
            );
            
            return {
                success: true,
                data: {
                    operationSpecificData: result.data,
                    telemetryData: result.telemetryData
                }
            };
        } finally {
            // Silent 모드 비활성화
            disableSilentMode();
        }
    } catch (error) {
        log.error(`Error in newFeatureDirect: ${error.message}`);
        return {
            success: false,
            error: {
                code: 'OPERATION_ERROR',
                message: error.message
            }
        };
    }
}
```

### **MCP 도구 등록**
```javascript
// ✅ DO: mcp-server/src/tools/new-feature.js
import { z } from 'zod';
import { newFeatureDirect } from '../core/direct-functions/new-feature.js';
import { handleApiResult, withNormalizedProjectRoot } from './utils.js';

export function registerNewFeatureTool(server) {
    server.addTool({
        name: "new_feature",
        description: "새로운 기능을 실행합니다",
        inputSchema: {
            type: "object",
            properties: {
                projectRoot: {
                    type: "string",
                    description: "프로젝트 루트 디렉토리 경로"
                },
                taskId: {
                    type: "string",
                    description: "태스크 ID"
                },
                param: {
                    type: "string",
                    description: "필수 파라미터"
                },
                tag: {
                    type: "string",
                    description: "태그 컨텍스트"
                }
            },
            required: ["projectRoot", "taskId", "param"]
        },
        execute: withNormalizedProjectRoot(async (args, { log, session }) => {
            try {
                const result = await newFeatureDirect(args, log, { session });
                return handleApiResult(result, log);
            } catch (error) {
                return handleApiError(error, log);
            }
        })
    });
}
```

## **테스트 구현**

### **단위 테스트**
```javascript
// ✅ DO: tests/unit/task-manager/new-feature.test.js
import { performNewFeature } from '../../../scripts/modules/task-manager/new-feature.js';
import { findTaskById, updateTask } from '../../../scripts/modules/task-manager/task-manager.js';

// 모킹
jest.mock('../../../scripts/modules/task-manager/task-manager.js');
jest.mock('../../../scripts/modules/ai-services-unified.js');

describe('New Feature', () => {
    beforeEach(() => {
        jest.clearAllMocks();
    });
    
    it('should perform new feature successfully', async () => {
        // 모킹 설정
        const mockTask = {
            id: '1',
            title: 'Test Task',
            description: 'Test Description',
            status: 'pending'
        };
        
        findTaskById.mockResolvedValue(mockTask);
        updateTask.mockResolvedValue(true);
        
        // AI 서비스 모킹
        const mockAiResponse = {
            mainResult: 'AI 처리 결과',
            telemetryData: { tokens: 100, cost: 0.001 }
        };
        
        generateTextService.mockResolvedValue(mockAiResponse);
        
        // 테스트 실행
        const result = await performNewFeature(
            '/path/to/tasks.json',
            '1',
            { requiredParam: 'test' }
        );
        
        // 검증
        expect(result.success).toBe(true);
        expect(result.data).toBeDefined();
        expect(findTaskById).toHaveBeenCalledWith('1', '/path/to/tasks.json');
        expect(updateTask).toHaveBeenCalled();
    });
    
    it('should handle missing task ID', async () => {
        await expect(performNewFeature(
            '/path/to/tasks.json',
            null,
            { requiredParam: 'test' }
        )).rejects.toThrow('태스크 ID가 필요합니다');
    });
    
    it('should handle task not found', async () => {
        findTaskById.mockResolvedValue(null);
        
        await expect(performNewFeature(
            '/path/to/tasks.json',
            '999',
            { requiredParam: 'test' }
        )).rejects.toThrow('태스크 999를 찾을 수 없습니다');
    });
});
```

### **통합 테스트**
```javascript
// ✅ DO: tests/integration/cli/new-feature.test.js
import { execSync } from 'child_process';
import path from 'path';

describe('New Feature CLI Integration', () => {
    const testProjectPath = path.join(__dirname, '../../fixtures/test-project');
    
    beforeEach(() => {
        // 테스트 프로젝트 설정
        setupTestProject(testProjectPath);
    });
    
    afterEach(() => {
        // 테스트 프로젝트 정리
        cleanupTestProject(testProjectPath);
    });
    
    it('should execute new feature command successfully', () => {
        const result = execSync(
            'task-master new-feature --id=1 --param=test',
            { cwd: testProjectPath, encoding: 'utf8' }
        );
        
        expect(result).toContain('새 기능이 성공적으로 실행되었습니다');
        expect(result).toContain('태스크 ID: 1');
    });
    
    it('should handle missing parameters', () => {
        expect(() => {
            execSync('task-master new-feature --id=1', { 
                cwd: testProjectPath, 
                encoding: 'utf8' 
            });
        }).toThrow();
    });
});
```

## **문서화**

### **README 업데이트**
```markdown
// ✅ DO: 새 기능 문서화
## 새 기능 (new-feature)

새로운 기능을 태스크에 적용합니다.

### 사용법

```bash
# 기본 사용법
task-master new-feature --id=1 --param=value

# JSON 출력
task-master new-feature --id=1 --param=value --output=json

# 특정 태그에서 실행
task-master new-feature --id=1 --param=value --tag=feature-branch
```

### 옵션

- `-i, --id <id>`: 태스크 ID (필수)
- `-p, --param <value>`: 필수 파라미터 (필수)
- `-o, --output <format>`: 출력 형식 (text|json, 기본값: text)
- `--tag <tag>`: 태그 컨텍스트 지정
- `-f, --file <file>`: 태스크 파일 경로

### 예시

```bash
# 태스크 1에 새 기능 적용
task-master new-feature --id=1 --param=optimization

# 결과를 JSON으로 출력
task-master new-feature --id=2 --param=analysis --output=json
```
```

### **API 문서**
```javascript
// ✅ DO: JSDoc 문서화
/**
 * 새로운 기능을 태스크에 적용합니다.
 * 
 * @param {string} tasksPath - 태스크 파일 경로
 * @param {string} taskId - 태스크 ID
 * @param {Object} options - 옵션 객체
 * @param {string} options.param - 필수 파라미터
 * @param {string} [options.outputFormat='text'] - 출력 형식
 * @param {Object} [context={}] - 컨텍스트 객체
 * @param {Object} [context.mcpLog] - MCP 로거
 * @param {string} [context.projectRoot] - 프로젝트 루트
 * @param {string} [context.tag] - 태그 컨텍스트
 * 
 * @returns {Promise<Object>} 실행 결과
 * @returns {boolean} returns.success - 성공 여부
 * @returns {Object} returns.data - 결과 데이터
 * @returns {Object} [returns.telemetryData] - 텔레메트리 데이터
 * 
 * @throws {Error} 태스크를 찾을 수 없는 경우
 * @throws {Error} 필수 파라미터가 누락된 경우
 * @throws {Error} AI 서비스 호출 실패 시
 * 
 * @example
 * ```javascript
 * const result = await performNewFeature(
 *   '/path/to/tasks.json',
 *   '1',
 *   { param: 'optimization' }
 * );
 * 
 * if (result.success) {
 *   console.log('성공:', result.data);
 * }
 * ```
 */
export async function performNewFeature(tasksPath, taskId, options, context = {}) {
    // 구현...
}
```

## **성능 최적화**

### **캐싱 구현**
```javascript
// ✅ DO: 성능 최적화를 위한 캐싱
import { getCachedOrExecute } from '../utils/cache-utils.js';

export async function performNewFeatureWithCache(tasksPath, taskId, options, context = {}) {
    const cacheKey = generateCacheKey('new-feature', { taskId, options });
    
    return await getCachedOrExecute(cacheKey, async () => {
        return await performNewFeature(tasksPath, taskId, options, context);
    });
}

function generateCacheKey(operation, params) {
    return `${operation}:${JSON.stringify(params)}`;
}
```

### **배치 처리**
```javascript
// ✅ DO: 여러 태스크에 대한 배치 처리
export async function performNewFeatureBatch(tasksPath, taskIds, options, context = {}) {
    const results = await Promise.allSettled(
        taskIds.map(taskId => 
            performNewFeature(tasksPath, taskId, options, context)
        )
    );
    
    return results.map((result, index) => ({
        taskId: taskIds[index],
        success: result.status === 'fulfilled',
        data: result.status === 'fulfilled' ? result.value : null,
        error: result.status === 'rejected' ? result.reason : null
    }));
}
```

## **에러 처리**

### **포괄적 에러 처리**
```javascript
// ✅ DO: 견고한 에러 처리
export async function performNewFeatureRobust(tasksPath, taskId, options, context = {}) {
    try {
        // 입력 검증
        validateInput(taskId, options);
        
        // 태스크 존재 확인
        const task = await findTaskById(taskId, tasksPath);
        if (!task) {
            throw new Error(`태스크 ${taskId}를 찾을 수 없습니다`);
        }
        
        // AI 서비스 호출 (재시도 포함)
        const aiResponse = await retryWithFallback(
            () => generateTextService({
                prompt: buildPrompt(task, options),
                model: getConfiguredModel('main'),
                commandName: 'new-feature',
                outputType: context.mcpLog ? 'mcp' : 'cli'
            }),
            () => generateTextService({
                prompt: buildPrompt(task, options),
                model: getConfiguredModel('fallback'),
                commandName: 'new-feature-fallback',
                outputType: context.mcpLog ? 'mcp' : 'cli'
            }),
            3
        );
        
        // 결과 처리
        const result = processResult(aiResponse.mainResult, task);
        
        // 저장
        await updateTask(taskId, result, tasksPath);
        
        return {
            success: true,
            data: result,
            telemetryData: aiResponse.telemetryData
        };
    } catch (error) {
        // 에러 로깅
        if (context.mcpLog) {
            context.mcpLog.error(`New feature failed: ${error.message}`);
        }
        
        // 사용자 친화적 에러 메시지
        const userMessage = getErrorMessage(error);
        
        throw new Error(userMessage);
    }
}

function getErrorMessage(error) {
    if (error.message.includes('태스크')) {
        return error.message;
    }
    
    if (error.message.includes('API')) {
        return 'AI 서비스에 일시적인 문제가 있습니다. 잠시 후 다시 시도해주세요.';
    }
    
    return '새 기능 실행 중 오류가 발생했습니다.';
}
```

---

**참고 파일:**
- [task-manager/](mdc:scripts/modules/task-manager/) - 핵심 로직 모듈
- [commands.js](mdc:scripts/modules/commands.js) - CLI 명령어
- [mcp-server/](mdc:mcp-server/) - MCP 서버 구현
- [tests/](mdc:tests/) - 테스트 파일들

  - ✅ DO: Ensure tagged system features work with flags
  - ✅ DO: Provide clear documentation about flag usage

By following these guidelines, new features will integrate smoothly with the Task Garage ecosystem while supporting the enhanced tagged task lists system for multi-context development workflows.
