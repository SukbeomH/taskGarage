# Task Garage 아키텍처 가이드

## **전체 시스템 구조**

### **핵심 컴포넌트**
```
Task Garage CLI
├── CLI Interface (Commander.js)
├── MCP Server (Model Context Protocol)
├── Core Logic Modules
├── AI Services Layer
└── Configuration Management
```

### **주요 디렉토리 구조**
- **`scripts/modules/`**: 핵심 비즈니스 로직
- **`mcp-server/`**: MCP 서버 구현
- **`src/`**: 공통 유틸리티 및 상수
- **`tests/`**: 테스트 파일들
- **`.cursor/rules/`**: Cursor 규칙 파일들

## **CLI 아키텍처**

### **명령어 등록 패턴**
```javascript
// ✅ DO: 표준 명령어 등록 구조
programInstance
    .command('command-name')
    .description('명령어 설명')
    .option('-f, --file <file>', 'Path to the tasks file', TASKMASTER_TASKS_FILE)
    .option('--tag <tag>', 'Specify tag context for task operations')
    .action(async (options) => {
        const taskMaster = initTaskMaster({
            tasksPath: options.file || true,
            tag: options.tag
        });
        
        const context = {
            projectRoot: taskMaster.getProjectRoot(),
            commandName: 'command-name',
            outputType: 'cli'
        };
        
        // 핵심 로직 호출
    });
```

### **TaskMaster 초기화 패턴**
```javascript
// ✅ DO: 모든 명령어에서 일관된 초기화
const taskMaster = initTaskMaster({
    tasksPath: options.file || true,
    tag: options.tag
});

const projectRoot = taskMaster.getProjectRoot();
const tasksPath = taskMaster.getTasksPath();
const tag = taskMaster.getCurrentTag();
```

## **MCP 서버 아키텍처**

### **MCP 도구 구조**
```
mcp-server/
├── src/
│   ├── tools/           # MCP 도구 구현
│   ├── core/            # 핵심 로직 래퍼
│   └── index.js         # 서버 진입점
└── server.js            # 서버 설정
```

### **MCP 도구 등록 패턴**
```javascript
// ✅ DO: MCP 도구 표준 등록
export function registerToolNameTool(server) {
    server.addTool({
        name: "tool_name",
        description: "Tool description",
        inputSchema: {
            type: "object",
            properties: {
                // 스키마 정의
            }
        },
        execute: withNormalizedProjectRoot(async (args, { log, session }) => {
            try {
                const result = await toolNameDirect(args, log, { session });
                return handleApiResult(result, log);
            } catch (error) {
                return handleApiError(error, log);
            }
        })
    });
}
```

### **Direct Function 래퍼 패턴**
```javascript
// ✅ DO: MCP용 핵심 로직 래퍼
export async function toolNameDirect(args, log, context = {}) {
    const { session } = context;
    
    try {
        const coreResult = await performToolNameAction(
            { /* parameters */ },
            { 
                session,
                mcpLog: createLogWrapper(log),
                projectRoot: args.projectRoot,
                commandNameFromContext: 'mcp_tool_tool_name',
                outputType: 'mcp'
            },
            'json'
        );

        return {
            success: true,
            data: {
                operationSpecificData: coreResult.actionData,
                telemetryData: coreResult.telemetryData
            }
        };
    } catch (error) {
        return { success: false, error: error.message };
    }
}
```

## **핵심 로직 모듈**

### **태스크 관리 모듈**
- **파일**: `scripts/modules/task-manager/`
- **주요 기능**: 태스크 CRUD, 태그 관리, 의존성 관리

```javascript
// ✅ DO: 태스크 관리 함수 구조
export async function addTask(tasksPath, options, context, outputFormat = 'text') {
    const { projectRoot, commandNameFromContext, outputType } = context;
    
    // AI 서비스 호출
    const aiServiceResponse = await generateObjectService({
        // AI 파라미터
        commandName: commandNameFromContext || 'add-task',
        outputType: outputType || 'cli'
    });
    
    // 핵심 로직 처리
    const result = processAiResponse(aiServiceResponse);
    
    // UI 출력 처리
    if (outputFormat === 'text' && aiServiceResponse.telemetryData) {
        displayAiUsageSummary(aiServiceResponse.telemetryData, 'cli');
    }
    
    return {
        actionData: result,
        telemetryData: aiServiceResponse.telemetryData
    };
}
```

### **AI 서비스 통합**
- **파일**: `scripts/modules/ai-services-unified.js`
- **기능**: 통합된 AI 서비스 레이어

```javascript
// ✅ DO: AI 서비스 호출 패턴
export async function generateObjectService(params) {
    const { commandName, outputType, ...otherParams } = params;
    
    // AI 제공자 선택 및 호출
    const result = await callAiProvider(otherParams);
    
    // 텔레메트리 데이터 생성
    const telemetryData = generateTelemetryData(result, commandName, outputType);
    
    return {
        mainResult: result,
        telemetryData
    };
}
```

## **태그 시스템 아키텍처**

### **태그된 태스크 리스트 구조**
```json
{
    "master": {
        "tasks": [...],
        "metadata": {...}
    },
    "feature-auth": {
        "tasks": [...],
        "metadata": {...}
    }
}
```

### **태그 관리 함수**
```javascript
// ✅ DO: 태그 관리 표준 패턴
export async function createTag(tasksPath, tagName, options, context, outputFormat) {
    const { projectRoot, commandNameFromContext, outputType } = context;
    
    // 태그 생성 로직
    const result = await performTagCreation(tasksPath, tagName, options);
    
    // UI 출력
    if (outputFormat === 'text') {
        displayTagCreationResult(result);
    }
    
    return result;
}
```

## **설정 관리 아키텍처**

### **설정 파일 구조**
```json
{
    "ai": {
        "main": "claude-3-5-sonnet",
        "research": "perplexity",
        "fallback": "gpt-4"
    },
    "parameters": {
        "maxTokens": 4000,
        "temperature": 0.7
    },
    "global": {
        "defaultTag": "master"
    }
}
```

### **설정 관리 함수**
```javascript
// ✅ DO: 설정 관리 패턴
export async function getModelConfiguration({ projectRoot }) {
    const configPath = path.join(projectRoot, '.taskmaster/config.json');
    
    if (!fs.existsSync(configPath)) {
        throw new ConfigurationError('Configuration file not found');
    }
    
    const config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
    return {
        success: true,
        data: {
            activeModels: config.ai,
            parameters: config.parameters
        }
    };
}
```

## **스크립트 실행 엔진**

### **스크립트 실행 구조**
```
Script Execution Engine
├── executeScript()      # 스크립트 실행
├── getScriptResult()    # 결과 조회
├── analyzeScriptResult() # 결과 분석
└── generateScriptReport() # 보고서 생성
```

### **스크립트 실행 패턴**
```javascript
// ✅ DO: 스크립트 실행 표준 패턴
export async function executeScript(command, options) {
    const { workingDirectory, timeout, shell, encoding, maxBuffer } = options;
    
    const scriptId = generateScriptId();
    const startTime = Date.now();
    
    try {
        const result = await execAsync(command, {
            cwd: workingDirectory,
            timeout,
            shell,
            encoding,
            maxBuffer
        });
        
        const endTime = Date.now();
        const duration = endTime - startTime;
        
        const scriptResult = {
            id: scriptId,
            command,
            workingDirectory,
            startTime,
            endTime,
            duration,
            exitCode: result.exitCode,
            success: result.exitCode === 0,
            stdout: result.stdout,
            stderr: result.stderr
        };
        
        saveScriptResult(scriptResult);
        return scriptResult;
        
    } catch (error) {
        // 에러 처리
    }
}
```

## **UI 및 출력 처리**

### **색상 및 스타일링**
```javascript
// ✅ DO: 일관된 UI 패턴
import chalk from 'chalk';
import boxen from 'boxen';

// 정보 메시지
console.log(chalk.blue('Processing...'));

// 성공 메시지
console.log(chalk.green('Success!'));

// 경고 메시지
console.log(chalk.yellow('Warning...'));

// 에러 메시지
console.error(chalk.red('Error: ...'));

// 박스 메시지
console.log(boxen(
    chalk.white.bold('Title') + '\n\n' + chalk.white('Content'),
    { padding: 1, borderColor: 'green', borderStyle: 'round' }
));
```

### **진행률 표시**
```javascript
// ✅ DO: ora를 사용한 로딩 표시
import ora from 'ora';

const spinner = ora('Processing...').start();
try {
    // 작업 수행
    spinner.succeed('Completed successfully');
} catch (error) {
    spinner.fail('Failed');
    throw error;
}
```

## **에러 처리 아키텍처**

### **에러 타입 정의**
```javascript
// ✅ DO: 커스텀 에러 클래스 사용
export class ConfigurationError extends Error {
    constructor(message) {
        super(message);
        this.name = 'ConfigurationError';
        this.code = 'CONFIG_MISSING';
    }
}

export class TaskNotFoundError extends Error {
    constructor(taskId) {
        super(`Task with ID ${taskId} not found`);
        this.name = 'TaskNotFoundError';
        this.taskId = taskId;
    }
}
```

### **에러 처리 패턴**
```javascript
// ✅ DO: 일관된 에러 처리
try {
    // 작업 수행
} catch (error) {
    if (error instanceof ConfigurationError) {
        // 설정 관련 에러 처리
        displayConfigurationError(error);
    } else if (error instanceof TaskNotFoundError) {
        // 태스크 관련 에러 처리
        displayTaskNotFoundError(error);
    } else {
        // 일반 에러 처리
        console.error(chalk.red(`Error: ${error.message}`));
    }
    
    if (getDebugFlag()) {
        console.error(error);
    }
    
    process.exit(1);
}
```

## **테스트 아키텍처**

### **테스트 구조**
```
tests/
├── unit/           # 단위 테스트
├── integration/    # 통합 테스트
├── e2e/           # 엔드투엔드 테스트
└── fixtures/      # 테스트 데이터
```

### **테스트 패턴**
```javascript
// ✅ DO: 테스트 표준 패턴
describe('addTask function', () => {
    beforeEach(() => {
        // 테스트 설정
    });
    
    afterEach(() => {
        // 정리 작업
    });
    
    it('should add a new task successfully', async () => {
        // 테스트 로직
    });
    
    it('should handle invalid input', async () => {
        // 에러 케이스 테스트
    });
});
```

## **성능 최적화**

### **비동기 처리**
```javascript
// ✅ DO: 모든 I/O 작업을 비동기로 처리
export async function processTasks(tasks) {
    const results = await Promise.all(
        tasks.map(async (task) => {
            return await processTask(task);
        })
    );
    
    return results;
}
```

### **메모리 관리**
```javascript
// ✅ DO: 큰 파일 처리 시 스트리밍 사용
import { createReadStream, createWriteStream } from 'fs';
import { pipeline } from 'stream/promises';

await pipeline(
    createReadStream(inputFile),
    createWriteStream(outputFile)
);
```

## **보안 고려사항**

### **입력 검증**
```javascript
// ✅ DO: 모든 사용자 입력 검증
function validateTaskId(id) {
    if (!/^\d+(\.\d+)?$/.test(id)) {
        throw new Error('Invalid task ID format');
    }
}

function validateFilePath(filePath, projectRoot) {
    const resolvedPath = path.resolve(filePath);
    if (!resolvedPath.startsWith(projectRoot)) {
        throw new Error('Invalid file path');
    }
}
```

### **API 키 보안**
```javascript
// ✅ DO: API 키를 환경 변수에서만 로드
function getApiKey(provider) {
    const key = process.env[`${provider.toUpperCase()}_API_KEY`];
    if (!key) {
        throw new Error(`${provider} API key not found in environment variables`);
    }
    return key;
}
```

## **확장성 고려사항**

### **모듈화된 구조**
```javascript
// ✅ DO: 기능별로 모듈 분리
// task-manager/add-task.js
// task-manager/remove-task.js
// task-manager/tag-management.js
// dependency-manager.js
// script-execution-engine.js
```

### **플러그인 아키텍처**
```javascript
// ✅ DO: 확장 가능한 구조 설계
export class PluginManager {
    constructor() {
        this.plugins = new Map();
    }
    
    register(name, plugin) {
        this.plugins.set(name, plugin);
    }
    
    execute(name, ...args) {
        const plugin = this.plugins.get(name);
        if (plugin) {
            return plugin.execute(...args);
        }
    }
}
```

---

**참고 파일:**
- [commands.js](mdc:scripts/modules/commands.js) - CLI 명령어 구현
- [task-manager/](mdc:scripts/modules/task-manager/) - 태스크 관리 로직
- [mcp-server/](mdc:mcp-server/) - MCP 서버 구현
- [ai-services-unified.js](mdc:scripts/modules/ai-services-unified.js) - AI 서비스 통합
  - Sets up `tasks.json` with tagged structure and initial task files
  - Configures project metadata (name, description, version)
  - Initializes state.json for tag system
  - Handles shell alias creation if requested
  - Works in both interactive and non-interactive modes